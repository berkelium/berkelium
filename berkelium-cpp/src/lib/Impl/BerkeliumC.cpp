// Copyright (c) 2013 The Berkelium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// =========================================
// WARNING:
//   THIS FILE IS AUTOMATICALLY GENERATED!
//   !! ANY CHANGES WILL BE OVERWRITTEN !!
//
// See berkelium/berkelium-api/update.sh
// =========================================

#include <Berkelium/API/HostVersion.hpp>
#include <Berkelium/API/BerkeliumFactory.hpp>
#include <Berkelium/API/Runtime.hpp>
#include <Berkelium/API/HostExecutable.hpp>
#include <Berkelium/API/Profile.hpp>
#include <Berkelium/API/Logger.hpp>
#include <Berkelium/API/LogDelegate.hpp>
#include <Berkelium/API/HostDelegate.hpp>
#include <Berkelium/API/Instance.hpp>
#include <Berkelium/API/Window.hpp>
#include <Berkelium/API/WindowDelegate.hpp>
#include <Berkelium/API/Tab.hpp>
#include <Berkelium/API/TabDelegate.hpp>

#include <berkelium.h>

#include <Berkelium/Impl/Impl.hpp>
#include <Berkelium/Impl/Manager.hpp>

#include <stdlib.h>
#include <string.h>

#include "BerkeliumC.hpp"

// =========================================
// C / C++ converter functions
// =========================================

inline char* newString(const std::string& str)
{
	int len = str.length() + 1;
	char* ret = (char*)malloc(len);
	memcpy(ret, str.c_str(), len);
	return ret;
}

inline Berkelium::RectRef mapInRectRef(BK_Env* env, BK_Rect& rect)
{
	// TODO
	return Berkelium::RectRef();
}


inline Berkelium::HostVersionRef mapInHostVersionRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::HostVersion* intId = (Berkelium::HostVersion*)env->mapIn(HostVersion, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::HostVersionRef();
	}

	Berkelium::HostVersionRef ret(manager->getHostVersion(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutHostVersionRef(BK_Env* env, Berkelium::HostVersionRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::HostVersionRef(bk));
	}


	BK_Env_Enum type(HostVersion);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::RuntimeRef mapInRuntimeRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Runtime* intId = (Berkelium::Runtime*)env->mapIn(Runtime, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::RuntimeRef();
	}

	Berkelium::RuntimeRef ret(manager->getRuntime(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutRuntimeRef(BK_Env* env, Berkelium::RuntimeRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::RuntimeRef(bk));
	}


	BK_Env_Enum type(Runtime);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::HostExecutableRef mapInHostExecutableRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::HostExecutable* intId = (Berkelium::HostExecutable*)env->mapIn(HostExecutable, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::HostExecutableRef();
	}

	Berkelium::HostExecutableRef ret(manager->getHostExecutable(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutHostExecutableRef(BK_Env* env, Berkelium::HostExecutableRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::HostExecutableRef(bk));
	}


	BK_Env_Enum type(HostExecutable);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::ProfileRef mapInProfileRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Profile* intId = (Berkelium::Profile*)env->mapIn(Profile, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::ProfileRef();
	}

	Berkelium::ProfileRef ret(manager->getProfile(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutProfileRef(BK_Env* env, Berkelium::ProfileRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::ProfileRef(bk));
	}


	BK_Env_Enum type(Profile);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::LoggerRef mapInLoggerRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Logger* intId = (Berkelium::Logger*)env->mapIn(Logger, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::LoggerRef();
	}

	Berkelium::LoggerRef ret(manager->getLogger(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutLoggerRef(BK_Env* env, Berkelium::LoggerRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::LoggerRef(bk));
	}


	BK_Env_Enum type(Logger);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::InstanceRef mapInInstanceRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Instance* intId = (Berkelium::Instance*)env->mapIn(Instance, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::InstanceRef();
	}

	Berkelium::InstanceRef ret(manager->getInstance(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutInstanceRef(BK_Env* env, Berkelium::InstanceRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::InstanceRef(bk));
	}


	BK_Env_Enum type(Instance);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::WindowRef mapInWindowRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Window* intId = (Berkelium::Window*)env->mapIn(Window, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::WindowRef();
	}

	Berkelium::WindowRef ret(manager->getWindow(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutWindowRef(BK_Env* env, Berkelium::WindowRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::WindowRef(bk));
	}


	BK_Env_Enum type(Window);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::TabRef mapInTabRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Tab* intId = (Berkelium::Tab*)env->mapIn(Tab, extId, env->data);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::TabRef();
	}

	Berkelium::TabRef ret(manager->getTab(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutTabRef(BK_Env* env, Berkelium::TabRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::TabRef(bk));
	}


	BK_Env_Enum type(Tab);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env->data);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env->data);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline BK_WindowList* mapOutWindowList(BK_Env* env, Berkelium::WindowListRef list)
{
	BK_WindowList* ret = (BK_WindowList*)malloc(sizeof(BK_WindowList));

	ret->size = list->size();
	ret->entrys = (BK_Window*)malloc(sizeof(BK_Window) * ret->size);

	int i = 0;
	for(Berkelium::WindowList::iterator it(list->begin()); it != list->end(); i++, it++) {
		ret->entrys[i] = mapOutWindowRef(env, *it);
	}

	return ret;
}

inline BK_TabList* mapOutTabList(BK_Env* env, Berkelium::TabListRef list)
{
	BK_TabList* ret = (BK_TabList*)malloc(sizeof(BK_TabList));

	ret->size = list->size();
	ret->entrys = (BK_Tab*)malloc(sizeof(BK_Tab) * ret->size);

	int i = 0;
	for(Berkelium::TabList::iterator it(list->begin()); it != list->end(); i++, it++) {
		ret->entrys[i] = mapOutTabRef(env, *it);
	}

	return ret;
}

// =========================================
// BK_Env_Enum to String
// =========================================

const char* BK_Env_Enum_To_String_Or_Null(BK_Env_Enum type)
{
	switch(type) {
		case HostVersion:
			return "HostVersion";

		case Runtime:
			return "Runtime";

		case HostExecutable:
			return "HostExecutable";

		case Profile:
			return "Profile";

		case Logger:
			return "Logger";

		case LogDelegate:
			return "LogDelegate";

		case HostDelegate:
			return "HostDelegate";

		case Instance:
			return "Instance";

		case Window:
			return "Window";

		case WindowDelegate:
			return "WindowDelegate";

		case Tab:
			return "Tab";

		case TabDelegate:
			return "TabDelegate";

		default:
			return NULL;
	}
}

const char* BK_Env_Enum_To_String_Or_Err(BK_Env_Enum type)
{
	const char* ret = BK_Env_Enum_To_String_Or_Null(type);
	if(ret == NULL) {
		return "Error";
	}
	return ret;
}

// =========================================
// interface HostVersion
// =========================================

extern "C" BK_Runtime BK_HostVersion_getRuntime(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_string BK_HostVersion_getVersionString(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getVersionString());
}

extern "C" bk_int32 BK_HostVersion_getMajor(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getMajor();
}

extern "C" bk_int32 BK_HostVersion_getMinor(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getMinor();
}

extern "C" bk_int32 BK_HostVersion_getBuild(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getBuild();
}

extern "C" bk_int32 BK_HostVersion_getPatch(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getPatch();
}

extern "C" bk_bool BK_HostVersion_isMinVersion(BK_Env* env, BK_HostVersion self, bk_string version)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(version == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("version"));
		return false;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isMinVersion(version);
}

extern "C" void BK_HostVersion_free(BK_Env* env, BK_HostVersion self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));
	if(!_this) {
		bk_error("already freed HostVersion %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for HostVersion %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free HostVersion %p!", _this.get());
	} else {
		delete (Berkelium::HostVersionRef*)result;
	}

}

// =========================================
// class BerkeliumFactory
// =========================================

extern "C" BK_Runtime BK_BerkeliumFactory_getDefaultRuntime(BK_Env* env)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::getDefaultRuntime());
}

extern "C" BK_Runtime BK_BerkeliumFactory_createRuntime(BK_Env* env)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::createRuntime());
}

extern "C" BK_Runtime BK_BerkeliumFactory_createRuntimeWithLog(BK_Env* env, BK_LogDelegate log)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::createRuntimeWithLog(mapInLogDelegateRef(env, log)));
}

// =========================================
// interface Runtime
// =========================================

extern "C" void BK_Runtime_setDefaultExecutable(BK_Env* env, BK_Runtime self, bk_string pathTo)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(pathTo == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("pathTo"));
		return;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->setDefaultExecutable(pathTo);
}

extern "C" BK_HostExecutable BK_Runtime_forExecutable(BK_Env* env, BK_Runtime self, bk_string pathTo)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(pathTo == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("pathTo"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->forExecutable(pathTo));
}

extern "C" BK_HostExecutable BK_Runtime_forSystemInstalled(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->forSystemInstalled());
}

extern "C" BK_Profile BK_Runtime_forProfile(BK_Env* env, BK_Runtime self, bk_string application)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(application == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("application"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->forProfile(application));
}

extern "C" BK_Profile BK_Runtime_getChromeProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getChromeProfile());
}

extern "C" BK_Profile BK_Runtime_getChromiumProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getChromiumProfile());
}

extern "C" BK_Profile BK_Runtime_forProfilePath(BK_Env* env, BK_Runtime self, bk_string path)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(path == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("path"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->forProfilePath(path));
}

extern "C" BK_Profile BK_Runtime_createTemporaryProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->createTemporaryProfile());
}

extern "C" BK_HostVersion BK_Runtime_forVersionS(BK_Env* env, BK_Runtime self, bk_string version)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(version == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("version"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->forVersion(version));
}

extern "C" BK_HostVersion BK_Runtime_forVersion4I(BK_Env* env, BK_Runtime self, bk_int32 vMajor, bk_int32 vMinor, bk_int32 vBuild, bk_int32 vPatch)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->forVersion(vMajor, vMinor, vBuild, vPatch));
}

extern "C" BK_Instance BK_Runtime_open(BK_Env* env, BK_Runtime self, BK_HostExecutable executable, BK_Profile profile)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutInstanceRef(env, _this->open(mapInHostExecutableRef(env, executable), mapInProfileRef(env, profile)));
}

extern "C" BK_Logger BK_Runtime_getLogger(BK_Env* env, BK_Runtime self, bk_string clazz, bk_string name)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(clazz == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("clazz"));
		return NULL;
	}
	if(name == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("name"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutLoggerRef(env, _this->getLogger(clazz, name));
}

extern "C" void BK_Runtime_addLogDelegate(BK_Env* env, BK_Runtime self, BK_LogDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addLogDelegate(mapInLogDelegateRef(env, delegate));
}

extern "C" void BK_Runtime_removeLogDelegate(BK_Env* env, BK_Runtime self, BK_LogDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeLogDelegate(mapInLogDelegateRef(env, delegate));
}

extern "C" void BK_Runtime_log(BK_Env* env, BK_Runtime self, BK_LogSource source, BK_LogType type, bk_string clazz, bk_string name, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(clazz == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("clazz"));
		return;
	}
	if(name == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("name"));
		return;
	}
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->log((Berkelium::LogSource)source, (Berkelium::LogType)type, clazz, name, message);
}

extern "C" void BK_Runtime_free(BK_Env* env, BK_Runtime self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));
	if(!_this) {
		bk_error("already freed Runtime %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Runtime %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Runtime %p!", _this.get());
	} else {
		delete (Berkelium::RuntimeRef*)result;
	}

	manager.reset();
}

// =========================================
// interface HostExecutable
// =========================================

extern "C" BK_Runtime BK_HostExecutable_getRuntime(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_string BK_HostExecutable_getPath(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getPath());
}

extern "C" BK_HostVersion BK_HostExecutable_getVersion(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->getVersion());
}

extern "C" void BK_HostExecutable_free(BK_Env* env, BK_HostExecutable self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));
	if(!_this) {
		bk_error("already freed HostExecutable %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for HostExecutable %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free HostExecutable %p!", _this.get());
	} else {
		delete (Berkelium::HostExecutableRef*)result;
	}

}

// =========================================
// interface Profile
// =========================================

extern "C" BK_Runtime BK_Profile_getRuntime(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_bool BK_Profile_isInUse(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isInUse();
}

extern "C" bk_bool BK_Profile_isFound(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isFound();
}

extern "C" bk_bool BK_Profile_isSameVersion(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isSameVersion();
}

extern "C" bk_bool BK_Profile_isTooNew(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isTooNew();
}

extern "C" bk_string BK_Profile_getApplicationName(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getApplicationName());
}

extern "C" bk_string BK_Profile_getProfilePath(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getProfilePath());
}

extern "C" void BK_Profile_setLocked(BK_Env* env, BK_Profile self, bk_bool locked)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->setLocked(locked);
}

extern "C" bk_bool BK_Profile_isLocked(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isLocked();
}

extern "C" void BK_Profile_free(BK_Env* env, BK_Profile self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));
	if(!_this) {
		bk_error("already freed Profile %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Profile %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Profile %p!", _this.get());
	} else {
		delete (Berkelium::ProfileRef*)result;
	}

}

// =========================================
// interface Logger
// =========================================

extern "C" void BK_Logger_debug(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->debug(message);
}

extern "C" void BK_Logger_info(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->info(message);
}

extern "C" void BK_Logger_warn(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->warn(message);
}

extern "C" void BK_Logger_error(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->error(message);
}

extern "C" void BK_Logger_free(BK_Env* env, BK_Logger self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));
	if(!_this) {
		bk_error("already freed Logger %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Logger %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Logger %p!", _this.get());
	} else {
		delete (Berkelium::LoggerRef*)result;
	}

}

// =========================================
// interface Instance
// =========================================

extern "C" BK_Runtime BK_Instance_getRuntime(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" void BK_Instance_internalUpdate(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->internalUpdate();
}

extern "C" void BK_Instance_close(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->close();
}

extern "C" BK_Profile BK_Instance_getProfile(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getProfile());
}

extern "C" BK_HostExecutable BK_Instance_getExecutable(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->getExecutable());
}

extern "C" void BK_Instance_addHostDelegate(BK_Env* env, BK_Instance self, BK_HostDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addHostDelegate(mapInHostDelegateRef(env, delegate));
}

extern "C" void BK_Instance_removeHostDelegate(BK_Env* env, BK_Instance self, BK_HostDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeHostDelegate(mapInHostDelegateRef(env, delegate));
}

extern "C" bk_int32 BK_Instance_getWindowCount(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getWindowCount();
}

extern "C" BK_WindowList* BK_Instance_getWindowList(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowList(env, _this->getWindowList());
}

extern "C" BK_Window BK_Instance_createWindow(BK_Env* env, BK_Instance self, bk_bool incognito)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowRef(env, _this->createWindow(incognito));
}

extern "C" void BK_Instance_free(BK_Env* env, BK_Instance self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));
	if(!_this) {
		bk_error("already freed Instance %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Instance %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Instance %p!", _this.get());
	} else {
		delete (Berkelium::InstanceRef*)result;
	}

}

// =========================================
// interface Window
// =========================================

extern "C" BK_Runtime BK_Window_getRuntime(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" void BK_Window_internalUpdate(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->internalUpdate();
}

extern "C" bk_int32 BK_Window_getTabCount(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getTabCount();
}

extern "C" BK_TabList* BK_Window_getTabList(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutTabList(env, _this->getTabList());
}

extern "C" BK_Tab BK_Window_createTab(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutTabRef(env, _this->createTab());
}

extern "C" BK_Instance BK_Window_getInstance(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutInstanceRef(env, _this->getInstance());
}

extern "C" void BK_Window_moveTo(BK_Env* env, BK_Window self, BK_Tab tab, bk_int32 index)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->moveTo(mapInTabRef(env, tab), index);
}

extern "C" bk_bool BK_Window_isIncognito(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isIncognito();
}

extern "C" void BK_Window_free(BK_Env* env, BK_Window self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));
	if(!_this) {
		bk_error("already freed Window %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Window %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Window %p!", _this.get());
	} else {
		delete (Berkelium::WindowRef*)result;
	}

}

// =========================================
// interface Tab
// =========================================

extern "C" BK_Runtime BK_Tab_getRuntime(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" void BK_Tab_internalUpdate(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->internalUpdate();
}

extern "C" void BK_Tab_close(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->close();
}

extern "C" void BK_Tab_sync(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->sync();
}

extern "C" BK_TabDelegate BK_Tab_getTabDelegate(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutTabDelegateRef(env, _this->getTabDelegate());
}

extern "C" void BK_Tab_addTabDelegate(BK_Env* env, BK_Tab self, BK_TabDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addTabDelegate(mapInTabDelegateRef(env, delegate));
}

extern "C" void BK_Tab_removeTabDelegate(BK_Env* env, BK_Tab self, BK_TabDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeTabDelegate(mapInTabDelegateRef(env, delegate));
}

extern "C" BK_Window BK_Tab_getWindow(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowRef(env, _this->getWindow());
}

extern "C" void BK_Tab_resize(BK_Env* env, BK_Tab self, bk_int32 width, bk_int32 height)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->resize(width, height);
}

extern "C" void BK_Tab_navigateTo(BK_Env* env, BK_Tab self, bk_string url)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(url == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("url"));
		return;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->navigateTo(url);
}

extern "C" void BK_Tab_free(BK_Env* env, BK_Tab self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));
	if(!_this) {
		bk_error("already freed Tab %p!", self);
		return;
	}
	env->free(_this.get(), env->data);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Tab %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Tab %p!", _this.get());
	} else {
		delete (Berkelium::TabRef*)result;
	}

}
