// Copyright (c) 2013 The Berkelium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// =========================================
// WARNING:
//   THIS FILE IS AUTOMATICALLY GENERATED!
//   !! ANY CHANGES WILL BE OVERWRITTEN !!
//
// See berkelium/berkelium-api/update.sh
// =========================================

#include <Berkelium/API/HostVersion.hpp>
#include <Berkelium/API/BerkeliumFactory.hpp>
#include <Berkelium/API/Runtime.hpp>
#include <Berkelium/API/HostExecutable.hpp>
#include <Berkelium/API/Profile.hpp>
#include <Berkelium/API/Logger.hpp>
#include <Berkelium/API/LogDelegate.hpp>
#include <Berkelium/API/HostDelegate.hpp>
#include <Berkelium/API/Instance.hpp>
#include <Berkelium/API/Window.hpp>
#include <Berkelium/API/WindowDelegate.hpp>
#include <Berkelium/API/Tab.hpp>
#include <Berkelium/API/TabDelegate.hpp>
#include <Berkelium/API/Update.hpp>

#include <berkelium.h>

#include <Berkelium/Impl/Impl.hpp>
#include <Berkelium/Impl/Manager.hpp>

#include <stdlib.h>
#include <string.h>

using Berkelium::RectRef;
using Berkelium::HostVersionRef;
using Berkelium::RuntimeRef;
using Berkelium::HostExecutableRef;
using Berkelium::ProfileRef;
using Berkelium::LoggerRef;
using Berkelium::LogDelegateRef;
using Berkelium::HostDelegateRef;
using Berkelium::InstanceRef;
using Berkelium::WindowRef;
using Berkelium::WindowDelegateRef;
using Berkelium::TabRef;
using Berkelium::TabDelegateRef;
using Berkelium::UpdateRef;
using Berkelium::LogSource;
using Berkelium::LogType;

class BkLogDelegateMapper : public Berkelium::LogDelegate
{
private:
	BK_Env* env;
	BK_LogDelegate delegate;
public:
	BkLogDelegateMapper(BK_Env* env, BK_LogDelegate delegate)
		: Berkelium::LogDelegate(),
		env(BK_Env_clone(env)),
		delegate(delegate) {
	}

	virtual ~BkLogDelegateMapper() {
		free(delegate);
		free(env);
	}

	virtual void log(RuntimeRef runtime, LogSource source, LogType type, const std::string& clazz, const std::string& name, const std::string& message);
};


class BkHostDelegateMapper : public Berkelium::HostDelegate
{
private:
	BK_Env* env;
	BK_HostDelegate delegate;
public:
	BkHostDelegateMapper(BK_Env* env, BK_HostDelegate delegate)
		: Berkelium::HostDelegate(),
		env(BK_Env_clone(env)),
		delegate(delegate) {
	}

	virtual ~BkHostDelegateMapper() {
		free(delegate);
		free(env);
	}

	virtual void onCrashed(InstanceRef instance);

	virtual void onClosed(InstanceRef instance);

	virtual void onPing(InstanceRef instance);
};


class BkWindowDelegateMapper : public Berkelium::WindowDelegate
{
private:
	BK_Env* env;
	BK_WindowDelegate delegate;
public:
	BkWindowDelegateMapper(BK_Env* env, BK_WindowDelegate delegate)
		: Berkelium::WindowDelegate(),
		env(BK_Env_clone(env)),
		delegate(delegate) {
	}

	virtual ~BkWindowDelegateMapper() {
		free(delegate);
		free(env);
	}
};


class BkTabDelegateMapper : public Berkelium::TabDelegate
{
private:
	BK_Env* env;
	BK_TabDelegate delegate;
public:
	BkTabDelegateMapper(BK_Env* env, BK_TabDelegate delegate)
		: Berkelium::TabDelegate(),
		env(BK_Env_clone(env)),
		delegate(delegate) {
	}

	virtual ~BkTabDelegateMapper() {
		free(delegate);
		free(env);
	}

	virtual void onClosed(TabRef tab);

	virtual void onTitleChanged(TabRef tab, const std::string& title);

	virtual void onPaint(TabRef tab);

	virtual void onPaintDone(TabRef tab, RectRef rect);

	virtual void onReady(TabRef tab);
};


class BkUpdateMapper : public Berkelium::Update
{
private:
	BK_Env* env;
	BK_Update delegate;
public:
	BkUpdateMapper(BK_Env* env, BK_Update delegate)
		: Berkelium::Update(),
		env(BK_Env_clone(env)),
		delegate(delegate) {
	}

	virtual ~BkUpdateMapper() {
		free(delegate);
		free(env);
	}

	virtual void update();
};



#include "BerkeliumC.hpp"

// =========================================
// C / C++ converter functions
// =========================================



inline Berkelium::LogDelegateRef mapInLogDelegateRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE_STATIC();

	BK_LogDelegate delegate = (BK_LogDelegate)env->mapIn(LogDelegate, extId, env);
	if(delegate == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
		return Berkelium::LogDelegateRef();
	}

	BERKELIUM_C_TRACE_RETURN(delegate);

	return Berkelium::LogDelegateRef(new BkLogDelegateMapper(env, delegate));
}


inline Berkelium::HostDelegateRef mapInHostDelegateRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE_STATIC();

	BK_HostDelegate delegate = (BK_HostDelegate)env->mapIn(HostDelegate, extId, env);
	if(delegate == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
		return Berkelium::HostDelegateRef();
	}

	BERKELIUM_C_TRACE_RETURN(delegate);

	return Berkelium::HostDelegateRef(new BkHostDelegateMapper(env, delegate));
}


inline Berkelium::WindowDelegateRef mapInWindowDelegateRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE_STATIC();

	BK_WindowDelegate delegate = (BK_WindowDelegate)env->mapIn(WindowDelegate, extId, env);
	if(delegate == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
		return Berkelium::WindowDelegateRef();
	}

	BERKELIUM_C_TRACE_RETURN(delegate);

	return Berkelium::WindowDelegateRef(new BkWindowDelegateMapper(env, delegate));
}


inline Berkelium::TabDelegateRef mapInTabDelegateRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE_STATIC();

	BK_TabDelegate delegate = (BK_TabDelegate)env->mapIn(TabDelegate, extId, env);
	if(delegate == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
		return Berkelium::TabDelegateRef();
	}

	BERKELIUM_C_TRACE_RETURN(delegate);

	return Berkelium::TabDelegateRef(new BkTabDelegateMapper(env, delegate));
}


inline Berkelium::UpdateRef mapInUpdateRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE_STATIC();

	BK_Update delegate = (BK_Update)env->mapIn(Update, extId, env);
	if(delegate == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
		return Berkelium::UpdateRef();
	}

	BERKELIUM_C_TRACE_RETURN(delegate);

	return Berkelium::UpdateRef(new BkUpdateMapper(env, delegate));
}

inline Berkelium::HostVersionRef mapInHostVersionRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::HostVersion* intId = (Berkelium::HostVersion*)env->mapIn(HostVersion, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::HostVersionRef();
	}

	Berkelium::HostVersionRef ret(manager->getHostVersion(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutHostVersionRef(BK_Env* env, Berkelium::HostVersionRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::HostVersionRef(bk));
	}


	BK_Env_Enum type(HostVersion);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::RuntimeRef mapInRuntimeRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Runtime* intId = (Berkelium::Runtime*)env->mapIn(Runtime, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::RuntimeRef();
	}

	Berkelium::RuntimeRef ret(manager->getRuntime(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutRuntimeRef(BK_Env* env, Berkelium::RuntimeRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::RuntimeRef(bk));
	}


	BK_Env_Enum type(Runtime);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::HostExecutableRef mapInHostExecutableRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::HostExecutable* intId = (Berkelium::HostExecutable*)env->mapIn(HostExecutable, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::HostExecutableRef();
	}

	Berkelium::HostExecutableRef ret(manager->getHostExecutable(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutHostExecutableRef(BK_Env* env, Berkelium::HostExecutableRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::HostExecutableRef(bk));
	}


	BK_Env_Enum type(HostExecutable);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::ProfileRef mapInProfileRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Profile* intId = (Berkelium::Profile*)env->mapIn(Profile, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::ProfileRef();
	}

	Berkelium::ProfileRef ret(manager->getProfile(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutProfileRef(BK_Env* env, Berkelium::ProfileRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::ProfileRef(bk));
	}


	BK_Env_Enum type(Profile);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::LoggerRef mapInLoggerRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Logger* intId = (Berkelium::Logger*)env->mapIn(Logger, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::LoggerRef();
	}

	Berkelium::LoggerRef ret(manager->getLogger(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutLoggerRef(BK_Env* env, Berkelium::LoggerRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::LoggerRef(bk));
	}


	BK_Env_Enum type(Logger);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::InstanceRef mapInInstanceRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Instance* intId = (Berkelium::Instance*)env->mapIn(Instance, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::InstanceRef();
	}

	Berkelium::InstanceRef ret(manager->getInstance(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutInstanceRef(BK_Env* env, Berkelium::InstanceRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::InstanceRef(bk));
	}


	BK_Env_Enum type(Instance);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::WindowRef mapInWindowRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Window* intId = (Berkelium::Window*)env->mapIn(Window, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::WindowRef();
	}

	Berkelium::WindowRef ret(manager->getWindow(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutWindowRef(BK_Env* env, Berkelium::WindowRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::WindowRef(bk));
	}


	BK_Env_Enum type(Window);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline Berkelium::TabRef mapInTabRef(BK_Env* env, bk_ext_obj extId)
{
	BERKELIUM_C_TRACE();

	Berkelium::Tab* intId = (Berkelium::Tab*)env->mapIn(Tab, extId, env);
	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(intId));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, intId);
		return Berkelium::TabRef();
	}

	Berkelium::TabRef ret(manager->getTab(intId));

	BERKELIUM_C_TRACE_RETURN(ret.get());

	return ret;
}

inline bk_ext_obj mapOutTabRef(BK_Env* env, Berkelium::TabRef bk)
{
	BERKELIUM_C_TRACE_STATIC();

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(bk));

	if(!manager) {
		bk_error("error: manager in '%s' %p not found!", __FUNCTION__, bk.get());
		return NULL;
	}

	if(!manager->locked(bk.get())) {
		manager->lock(bk.get(), new Berkelium::TabRef(bk));
	}


	BK_Env_Enum type(Tab);

	bk_ext_obj ret = env->mapOut(type, bk.get(), env);

	if(ret == NULL) {
		ret = env->mapNew(type, bk.get(), NULL, env);
	}

	if(ret == NULL) {
		bk_error("error: '%s' returned NULL!", __FUNCTION__);
	}

	BERKELIUM_C_TRACE_RETURN(ret);

	return ret;
}

inline BK_WindowList* mapOutWindowList(BK_Env* env, Berkelium::WindowListRef list)
{
	BK_WindowList* ret = (BK_WindowList*)malloc(sizeof(BK_WindowList));

	ret->size = list->size();
	ret->entrys = (BK_Window*)malloc(sizeof(BK_Window) * ret->size);

	int i = 0;
	for(Berkelium::WindowList::iterator it(list->begin()); it != list->end(); i++, it++) {
		ret->entrys[i] = mapOutWindowRef(env, *it);
	}

	return ret;
}

inline BK_TabList* mapOutTabList(BK_Env* env, Berkelium::TabListRef list)
{
	BK_TabList* ret = (BK_TabList*)malloc(sizeof(BK_TabList));

	ret->size = list->size();
	ret->entrys = (BK_Tab*)malloc(sizeof(BK_Tab) * ret->size);

	int i = 0;
	for(Berkelium::TabList::iterator it(list->begin()); it != list->end(); i++, it++) {
		ret->entrys[i] = mapOutTabRef(env, *it);
	}

	return ret;
}

// =========================================
// BK_Env_Enum to String
// =========================================

const char* BK_Env_Enum_To_String_Or_Null(BK_Env_Enum type)
{
	switch(type) {
		case HostVersion:
			return "HostVersion";

		case Runtime:
			return "Runtime";

		case HostExecutable:
			return "HostExecutable";

		case Profile:
			return "Profile";

		case Logger:
			return "Logger";

		case LogDelegate:
			return "LogDelegate";

		case HostDelegate:
			return "HostDelegate";

		case Instance:
			return "Instance";

		case Window:
			return "Window";

		case WindowDelegate:
			return "WindowDelegate";

		case Tab:
			return "Tab";

		case TabDelegate:
			return "TabDelegate";

		case Update:
			return "Update";

		default:
			return NULL;
	}
}

const char* BK_Env_Enum_To_String_Or_Err(BK_Env_Enum type)
{
	const char* ret = BK_Env_Enum_To_String_Or_Null(type);
	if(ret == NULL) {
		return "Error";
	}
	return ret;
}

// =========================================
// interface HostVersion
// =========================================

extern "C" BK_Runtime BK_HostVersion_getRuntime(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_string BK_HostVersion_getVersionString(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getVersionString());
}

extern "C" bk_int32 BK_HostVersion_getMajor(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getMajor();
}

extern "C" bk_int32 BK_HostVersion_getMinor(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getMinor();
}

extern "C" bk_int32 BK_HostVersion_getBuild(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getBuild();
}

extern "C" bk_int32 BK_HostVersion_getPatch(BK_Env* env, BK_HostVersion self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getPatch();
}

extern "C" bk_bool BK_HostVersion_isMinVersion(BK_Env* env, BK_HostVersion self, bk_string version)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(version == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("version"));
		return false;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isMinVersion(version);
}

extern "C" void BK_HostVersion_free(BK_Env* env, BK_HostVersion self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostVersionRef _this(mapInHostVersionRef(env, self));
	if(!_this) {
		bk_error("already freed HostVersion %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for HostVersion %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free HostVersion %p!", _this.get());
	} else {
		delete (Berkelium::HostVersionRef*)result;
	}

}

// =========================================
// class BerkeliumFactory
// =========================================

extern "C" BK_Runtime BK_BerkeliumFactory_getDefaultRuntime(BK_Env* env)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::getDefaultRuntime());
}

extern "C" BK_Runtime BK_BerkeliumFactory_createRuntime(BK_Env* env)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::createRuntime());
}

extern "C" BK_Runtime BK_BerkeliumFactory_createRuntimeWithLog(BK_Env* env, BK_LogDelegate log)
{
	BERKELIUM_C_TRACE_STATIC();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	return mapOutRuntimeRef(env, Berkelium::BerkeliumFactory::createRuntimeWithLog(mapInLogDelegateRef(env, log)));
}

// =========================================
// interface Runtime
// =========================================

extern "C" bk_string BK_Runtime_getDebugObjectStats(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getDebugObjectStats());
}

extern "C" void BK_Runtime_update(BK_Env* env, BK_Runtime self, bk_int32 timeout)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->update(timeout);
}

extern "C" void BK_Runtime_addUpdateEvent(BK_Env* env, BK_Runtime self, BK_Update update, bk_int32 timeout)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addUpdateEvent(mapInUpdateRef(env, update), timeout);
}

extern "C" void BK_Runtime_removeUpdateEvent(BK_Env* env, BK_Runtime self, BK_Update update)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeUpdateEvent(mapInUpdateRef(env, update));
}

extern "C" void BK_Runtime_setDefaultExecutable(BK_Env* env, BK_Runtime self, bk_string pathTo)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(pathTo == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("pathTo"));
		return;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->setDefaultExecutable(pathTo);
}

extern "C" BK_HostExecutable BK_Runtime_forExecutable(BK_Env* env, BK_Runtime self, bk_string pathTo)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(pathTo == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("pathTo"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->forExecutable(pathTo));
}

extern "C" BK_HostExecutable BK_Runtime_forSystemInstalled(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->forSystemInstalled());
}

extern "C" BK_Profile BK_Runtime_forProfile(BK_Env* env, BK_Runtime self, bk_string application)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(application == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("application"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->forProfile(application));
}

extern "C" BK_Profile BK_Runtime_getChromeProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getChromeProfile());
}

extern "C" BK_Profile BK_Runtime_getChromiumProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getChromiumProfile());
}

extern "C" BK_Profile BK_Runtime_forProfilePath(BK_Env* env, BK_Runtime self, bk_string path)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(path == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("path"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->forProfilePath(path));
}

extern "C" BK_Profile BK_Runtime_createTemporaryProfile(BK_Env* env, BK_Runtime self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->createTemporaryProfile());
}

extern "C" BK_HostVersion BK_Runtime_forVersionS(BK_Env* env, BK_Runtime self, bk_string version)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(version == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("version"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->forVersion(version));
}

extern "C" BK_HostVersion BK_Runtime_forVersion4I(BK_Env* env, BK_Runtime self, bk_int32 vMajor, bk_int32 vMinor, bk_int32 vBuild, bk_int32 vPatch)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->forVersion(vMajor, vMinor, vBuild, vPatch));
}

extern "C" BK_Instance BK_Runtime_open(BK_Env* env, BK_Runtime self, BK_HostExecutable executable, BK_Profile profile)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutInstanceRef(env, _this->open(mapInHostExecutableRef(env, executable), mapInProfileRef(env, profile)));
}

extern "C" BK_Logger BK_Runtime_getLogger(BK_Env* env, BK_Runtime self, bk_string clazz, bk_string name)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(clazz == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("clazz"));
		return NULL;
	}
	if(name == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("name"));
		return NULL;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutLoggerRef(env, _this->getLogger(clazz, name));
}

extern "C" void BK_Runtime_addLogDelegate(BK_Env* env, BK_Runtime self, BK_LogDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addLogDelegate(mapInLogDelegateRef(env, delegate));
}

extern "C" void BK_Runtime_removeLogDelegate(BK_Env* env, BK_Runtime self, BK_LogDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeLogDelegate(mapInLogDelegateRef(env, delegate));
}

extern "C" void BK_Runtime_log(BK_Env* env, BK_Runtime self, BK_LogSource source, BK_LogType type, bk_string clazz, bk_string name, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(clazz == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("clazz"));
		return;
	}
	if(name == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("name"));
		return;
	}
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->log((Berkelium::LogSource)source, (Berkelium::LogType)type, clazz, name, message);
}

extern "C" void BK_Runtime_free(BK_Env* env, BK_Runtime self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::RuntimeRef _this(mapInRuntimeRef(env, self));
	if(!_this) {
		bk_error("already freed Runtime %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Runtime %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Runtime %p!", _this.get());
	} else {
		delete (Berkelium::RuntimeRef*)result;
	}

	manager.reset();
}

// =========================================
// interface HostExecutable
// =========================================

extern "C" BK_Runtime BK_HostExecutable_getRuntime(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_string BK_HostExecutable_getPath(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getPath());
}

extern "C" BK_HostVersion BK_HostExecutable_getVersion(BK_Env* env, BK_HostExecutable self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostVersionRef(env, _this->getVersion());
}

extern "C" void BK_HostExecutable_free(BK_Env* env, BK_HostExecutable self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::HostExecutableRef _this(mapInHostExecutableRef(env, self));
	if(!_this) {
		bk_error("already freed HostExecutable %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for HostExecutable %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free HostExecutable %p!", _this.get());
	} else {
		delete (Berkelium::HostExecutableRef*)result;
	}

}

// =========================================
// interface Profile
// =========================================

extern "C" BK_Runtime BK_Profile_getRuntime(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_bool BK_Profile_isInUse(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isInUse();
}

extern "C" bk_bool BK_Profile_isFound(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isFound();
}

extern "C" bk_bool BK_Profile_isSameVersion(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isSameVersion();
}

extern "C" bk_bool BK_Profile_isTooNew(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isTooNew();
}

extern "C" bk_string BK_Profile_getApplicationName(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getApplicationName());
}

extern "C" bk_string BK_Profile_getProfilePath(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return newString(_this->getProfilePath());
}

extern "C" void BK_Profile_setLocked(BK_Env* env, BK_Profile self, bk_bool locked)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->setLocked(locked);
}

extern "C" bk_bool BK_Profile_isLocked(BK_Env* env, BK_Profile self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isLocked();
}

extern "C" void BK_Profile_free(BK_Env* env, BK_Profile self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::ProfileRef _this(mapInProfileRef(env, self));
	if(!_this) {
		bk_error("already freed Profile %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Profile %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Profile %p!", _this.get());
	} else {
		delete (Berkelium::ProfileRef*)result;
	}

}

// =========================================
// interface Logger
// =========================================

extern "C" void BK_Logger_debug(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->debug(message);
}

extern "C" void BK_Logger_info(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->info(message);
}

extern "C" void BK_Logger_warn(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->warn(message);
}

extern "C" void BK_Logger_error(BK_Env* env, BK_Logger self, bk_string message)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(message == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("message"));
		return;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->error(message);
}

extern "C" void BK_Logger_free(BK_Env* env, BK_Logger self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::LoggerRef _this(mapInLoggerRef(env, self));
	if(!_this) {
		bk_error("already freed Logger %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Logger %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Logger %p!", _this.get());
	} else {
		delete (Berkelium::LoggerRef*)result;
	}

}

// =========================================
// interface Instance
// =========================================

extern "C" BK_Runtime BK_Instance_getRuntime(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" void BK_Instance_close(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->close();
}

extern "C" BK_Profile BK_Instance_getProfile(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutProfileRef(env, _this->getProfile());
}

extern "C" BK_HostExecutable BK_Instance_getExecutable(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutHostExecutableRef(env, _this->getExecutable());
}

extern "C" void BK_Instance_addHostDelegate(BK_Env* env, BK_Instance self, BK_HostDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addHostDelegate(mapInHostDelegateRef(env, delegate));
}

extern "C" void BK_Instance_removeHostDelegate(BK_Env* env, BK_Instance self, BK_HostDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeHostDelegate(mapInHostDelegateRef(env, delegate));
}

extern "C" bk_int32 BK_Instance_getWindowCount(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getWindowCount();
}

extern "C" BK_WindowList* BK_Instance_getWindowList(BK_Env* env, BK_Instance self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowList(env, _this->getWindowList());
}

extern "C" BK_Window BK_Instance_createWindow(BK_Env* env, BK_Instance self, bk_bool incognito)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowRef(env, _this->createWindow(incognito));
}

extern "C" void BK_Instance_free(BK_Env* env, BK_Instance self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::InstanceRef _this(mapInInstanceRef(env, self));
	if(!_this) {
		bk_error("already freed Instance %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Instance %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Instance %p!", _this.get());
	} else {
		delete (Berkelium::InstanceRef*)result;
	}

}

// =========================================
// interface Window
// =========================================

extern "C" BK_Runtime BK_Window_getRuntime(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" bk_int32 BK_Window_getTabCount(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return 0;
	}

	return _this->getTabCount();
}

extern "C" BK_TabList* BK_Window_getTabList(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutTabList(env, _this->getTabList());
}

extern "C" BK_Tab BK_Window_createTab(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutTabRef(env, _this->createTab());
}

extern "C" BK_Instance BK_Window_getInstance(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutInstanceRef(env, _this->getInstance());
}

extern "C" void BK_Window_moveTo(BK_Env* env, BK_Window self, BK_Tab tab, bk_int32 index)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->moveTo(mapInTabRef(env, tab), index);
}

extern "C" bk_bool BK_Window_isIncognito(BK_Env* env, BK_Window self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return false;
	}

	return _this->isIncognito();
}

extern "C" void BK_Window_free(BK_Env* env, BK_Window self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::WindowRef _this(mapInWindowRef(env, self));
	if(!_this) {
		bk_error("already freed Window %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Window %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Window %p!", _this.get());
	} else {
		delete (Berkelium::WindowRef*)result;
	}

}

// =========================================
// interface Tab
// =========================================

extern "C" BK_Runtime BK_Tab_getRuntime(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutRuntimeRef(env, _this->getRuntime());
}

extern "C" void BK_Tab_close(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->close();
}

extern "C" void BK_Tab_sync(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->sync();
}

extern "C" void BK_Tab_addTabDelegate(BK_Env* env, BK_Tab self, BK_TabDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->addTabDelegate(mapInTabDelegateRef(env, delegate));
}

extern "C" void BK_Tab_removeTabDelegate(BK_Env* env, BK_Tab self, BK_TabDelegate delegate)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->removeTabDelegate(mapInTabDelegateRef(env, delegate));
}

extern "C" BK_Window BK_Tab_getWindow(BK_Env* env, BK_Tab self)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return NULL;
	}

	return mapOutWindowRef(env, _this->getWindow());
}

extern "C" void BK_Tab_resize(BK_Env* env, BK_Tab self, bk_int32 width, bk_int32 height)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->resize(width, height);
}

extern "C" void BK_Tab_navigateTo(BK_Env* env, BK_Tab self, bk_string url)
{
	BERKELIUM_C_TRACE();
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	// NPE check
	if(url == NULL) {
		env->NPE(strdup(__FUNCTION__), strdup("url"));
		return;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));

	if(!_this) {
		bk_error("error: _this in '%s' %p not found!", __FUNCTION__, self);
		return;
	}

	_this->navigateTo(url);
}

extern "C" void BK_Tab_free(BK_Env* env, BK_Tab self)
{
	if(env == NULL) {
		env = &simpleBerkeliumEnv::env;
	}

	Berkelium::TabRef _this(mapInTabRef(env, self));
	if(!_this) {
		bk_error("already freed Tab %p!", self);
		return;
	}
	env->free(_this.get(), env);

	Berkelium::impl::ManagerRef manager(Berkelium::impl::getManager(_this));
	if(!manager) {
		bk_error("can't find manager for Tab %p!", self);
		return;
	}
	void* result = manager->unlock(_this.get());

	if(result == NULL) {
		bk_error("can't free Tab %p!", _this.get());
	} else {
		delete (Berkelium::TabRef*)result;
	}

}

void BkLogDelegateMapper::log(RuntimeRef runtime, LogSource source, LogType type, const std::string& clazz, const std::string& name, const std::string& message)
{
	delegate->log(env, delegate, mapOutRuntimeRef(env, runtime), (BK_LogSource)0/*TODO*/, (BK_LogType)0/*TODO*/, newString(clazz), newString(name), newString(message));
}

void BkHostDelegateMapper::onCrashed(InstanceRef instance)
{
	delegate->onCrashed(env, delegate, mapOutInstanceRef(env, instance));
}

void BkHostDelegateMapper::onClosed(InstanceRef instance)
{
	delegate->onClosed(env, delegate, mapOutInstanceRef(env, instance));
}

void BkHostDelegateMapper::onPing(InstanceRef instance)
{
	delegate->onPing(env, delegate, mapOutInstanceRef(env, instance));
}

void BkTabDelegateMapper::onClosed(TabRef tab)
{
	delegate->onClosed(env, delegate, mapOutTabRef(env, tab));
}

void BkTabDelegateMapper::onTitleChanged(TabRef tab, const std::string& title)
{
	delegate->onTitleChanged(env, delegate, mapOutTabRef(env, tab), newString(title));
}

void BkTabDelegateMapper::onPaint(TabRef tab)
{
	delegate->onPaint(env, delegate, mapOutTabRef(env, tab));
}

void BkTabDelegateMapper::onPaintDone(TabRef tab, RectRef rect)
{
	delegate->onPaintDone(env, delegate, mapOutTabRef(env, tab), mapOutRectRef(env, rect));
}

void BkTabDelegateMapper::onReady(TabRef tab)
{
	delegate->onReady(env, delegate, mapOutTabRef(env, tab));
}

void BkUpdateMapper::update()
{
	delegate->update(env, delegate);
}
